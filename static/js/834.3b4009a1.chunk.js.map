{"version":3,"file":"static/js/834.3b4009a1.chunk.js","mappings":"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","sources":["modules/scaling.js"],"sourcesContent":["import './../css/scaling.css';\nimport React from 'react';\nimport JXG, { COORDS_BY_SCREEN } from 'jsxgraph';\n\nimport { calculateScaledScore } from './results';\n\nimport SUBJECTS from '../data/all_subjects.json';\nimport { getScalingData } from './data';\n  \nconst COLORS = [\n  'steelblue',\n  'orangered',\n  '#05b378', // green\n  'darkviolet',\n  'orange',\n  'brown',\n  'magenta'\n];\n\nconst BOUNDING_BOX = [-9, 103, 113, -6]; // min x, max y, max x, min y\n\nconst LEGEND_WIDTH = 110;\n\nconst SUBJECT_LABELS_ZOOM_THRESHOLD = 1.7;\nconst MOBILE_LEGEND_ZOOM_THRESHOLD = 10;\n\n// replace default font\nJXG.Options.text.cssDefaultStyle = 'z-index: 0';\nJXG.Options.text.highlightCssDefaultStyle = '';\n\nexport default class ScalingGraph extends React.Component {\n  componentDidMount() {\n    this.board = JXG.JSXGraph.initBoard(\"jsxgraph\", { \n      axis: true, \n      maxFrameRate: 30,\n      boundingbox: BOUNDING_BOX, \n      maxboundingbox: [-100, 200, 200, -100],\n      showCopyright: false, \n      showInfobox: false,\n      // showNavigation: false,\n      zoom: {\n        factorX: 1.25,  // horizontal zoom factor (multiplied to JXG.Board#zoomX)\n        factorY: 1.25,  // vertical zoom factor (multiplied to JXG.Board#zoomY)\n        wheel: true,     // allow zooming by mouse wheel or\n                   // by pinch-to-toom gesture on touch devices\n        needShift: false,   // mouse wheel zooming needs pressing of the shift key\n        min: 1,        // minimal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomOut\n        max: 50,       // maximal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomIn\n      \n        pinchHorizontal: false, // Allow pinch-to-zoom to zoom only horizontal axis\n        pinchVertical: false,   // Allow pinch-to-zoom to zoom only vertical axis\n        pinchSensitivity: 7    // Sensitivity (in degrees) for recognizing horizontal or vertical pinch-to-zoom gestures.\n      },\n      pan: {\n        enabled: true,   // Allow panning\n        needTwoFingers: false, // panning is done with two fingers on touch devices\n        needShift: false, // mouse panning needs pressing of the shift key\n      },\n      navbar:  {\n        strokeColor: '#333333',\n        fillColor: 'transparent',\n        highlightFillColor: '#aaaaaa',\n        padding: '0px',\n        position: 'absolute',\n        fontSize: '14px',\n        cursor: 'pointer',\n        zIndex: '100',\n        right: '5px',\n        bottom: '0px',\n      }\n    });\n    \n    this.legend = JXG.JSXGraph.initBoard(\"jsxlegend\", { \n      boundingbox: [0, 120, 20, 0], // min x, max y, max x, min y\n      maxFrameRate: 1,\n      registerEvents: false,\n      showCopyright: false, \n      showInfobox: false,\n      showNavigation: false,\n      zoom: {\n        factorX: 1, \n        factorY: 1, \n        wheel: false,    \n        needShift: true, \n        min: 1,      \n        max: 1, \n      \n        pinchHorizontal: false,\n        pinchVertical: false, \n        pinchSensitivity: 7 \n      },\n      pan: {\n        enabled: false,\n        needTwoFingers: true,\n        needShift: true,\n      },\n    }); \n\n    this.addZoomLevelListeners(); // this could be further optimised by only updating subject label listener, not whole legend listener\n    this.createMouseCoordinates();\n\n    this.originalObjects = [...this.board.objectsList]; // this needs to be after the mouse coordinates is created so it is preserved\n    this.points = [];\n    this.subjects = [];\n    this.year = 2022;\n\n    this.componentDidUpdate();\n  }\n\n  clearBoard() {\n    let objectsList = [...this.board.objectsList];\n    for (let index = objectsList.length - 1; index >= 0; index -= 1) {\n      let object = objectsList[index];\n      if (object.elType === \"line\" || object.elType === \"curve\" || (object.elType === \"text\" && object.htmlStr.length > 3 && object.visProp.cssclass !== \"mouseCoordinates\") || (object.elType === \"point\" && object.Xjc !== null) || !this.originalObjects.includes(object))\n        this.board.removeObject(object.id);\n    }\n  }\n\n  plotScalingFunctions() {\n    for (let [subjectIndex, subjectCode] of this.subjects.entries()) {  // entries on a list does enumerate\n      // create function\n      const scalingData = getScalingData(this.props.year);\n      let a = scalingData[subjectCode][\"a\"];\n      let b = scalingData[subjectCode][\"b\"];\n      let c = scalingData[subjectCode][\"c\"];\n      let subjectFunction = this.board.create('functiongraph', [function(x){\n        return (a / (1 + Math.exp(-b * (x - c))));\n      }, 0, 100], {strokeColor: COLORS[subjectIndex % COLORS.length]});   // modulus ensures colours repeat if exhausted\n      subjectFunction.hasPoint = function(x, y) {return false;}; // disable highlighting\n    }\n  }\n\n  clearLegend() {\n    let legendObjectsList = [...this.legend.objectsList];\n    for (let index = legendObjectsList.length - 1; index >= 0; index -= 1) {\n      let object = legendObjectsList[index];\n      this.legend.removeObject(object.id);\n    }\n  }\n\n  createLegend() {\n    let subjectsNames = this.subjects.map((subjectCode) => {return SUBJECTS[subjectCode]});\n    let longestSubjectName = subjectsNames.reduce((subject1, subject2) => {return (subject1.length > subject2.length) ? subject1 : subject2});\n    let numLines = Math.ceil(longestSubjectName.length / 12);\n    let rowHeight = numLines * 9 + 10;\n\n    let legend = this.legend.create('legend', [0, 100], {labels: subjectsNames, colors: COLORS, rowHeight: rowHeight} );\n\n    let legendHeight = legend.lines.at(-1).getTextAnchor().scrCoords.at(-1) + rowHeight + this.maxWidth / 30;\n    document.getElementById('jsxlegend').style.top = `${this.graphHeight - legendHeight}px`;\n    this.legend.resizeContainer(LEGEND_WIDTH, legendHeight, false, true);\n  }\n\n  plotPoints() {\n    // determine whether to show the points, at the current zoom level\n    let boundingBox = this.board.getBoundingBox();\n    let zoomFactor = (BOUNDING_BOX[2] - BOUNDING_BOX[0]) / (boundingBox[2] - boundingBox[0]);\n    let showLabels = (zoomFactor >= SUBJECT_LABELS_ZOOM_THRESHOLD);\n\n    for (let subjectCode of this.subjects) {\n      // plot raw score input\n      let rawScore = this.props.subjects[subjectCode];\n      if (rawScore) {\n        let scaledScore = calculateScaledScore(rawScore, subjectCode, this.props.year);\n        let point = this.board.create('point', [rawScore, scaledScore], {face: \"cross\", name: SUBJECTS[subjectCode], withLabel: true});\n        point.label.setAttribute({offset: [10, -4]});\n        if (!showLabels) point.setAttribute({withLabel: false});\n        point.hasPoint = function(x, y) {return false;}; // disable highlighting\n        this.points.push(point);\n      }\n    }\n  }\n\n  addZoomLevelListeners() {\n    function zoomFactorChange(zoomFactor, previousZoomFactor, thresholdZoomFactor) {\n      // tests whether the zoom factor has crossed the threshold (for optimisation purposes so no redundant attribute setting)\n      if (zoomFactor >= thresholdZoomFactor) {\n        return previousZoomFactor < thresholdZoomFactor;\n      } else {\n        return previousZoomFactor > thresholdZoomFactor;\n      }\n    }\n\n    // returns a tuple representing a rectangle of space [x, y, width, height]\n    function getCoordinate(point) {\n      /* These values include the point itself (whereas the current versions do not) so a larger area is considered occupied\n      const xCoord = point.coords.scrCoords[1];\n      const yCoord = point.coords.scrCoords[2];\n      const width =  point.label.rendNode.offsetWidth + Math.abs(point.label.visProp.offset[0]);\n      const height = point.label.rendNode.offsetHeight + Math.abs(point.label.visProp.offset[1]);   // only works because text below point\n      */\n\n      const xCoord = point.label.coords.scrCoords[1];\n      const yCoord = point.label.coords.scrCoords[2];\n      const width =  point.label.rendNode.offsetWidth;\n      const height = point.label.rendNode.offsetHeight;\n      return [xCoord, yCoord, width, height];\n    }\n    \n    // only show labels if they don't overlap with others\n    function isFreeSpace(coordinate, occupiedCoordinates) {\n      const [xCoord, yCoord, width, height] = coordinate;\n      for (const [minX, minY, maxWidth, maxHeight] of occupiedCoordinates) {\n        const xCollision = (\n          (xCoord >= minX && xCoord <= minX + maxWidth) || (xCoord + width >= minX && xCoord + width <= minX + maxWidth)  || // check if xCoord is within occupied space\n          (minX >= xCoord && minX <= xCoord + width) || (minX + maxWidth >= xCoord && minX + maxWidth <= xCoord + width)     // check if occupied coordinate is within xCoord\n        );\n        const yCollision = (\n          (yCoord >= minY && yCoord <= minY + maxHeight) || (yCoord + height >= minY && yCoord + height <= minY + maxHeight) ||\n          (minY >= yCoord && minY <= yCoord + height) || (minY + maxHeight >= yCoord && minY + maxHeight <= yCoord + height)\n          );\n        if (xCollision && yCollision) return false;\n      }\n      return true;\n    }\n\n    this.subjectsWithLabels = [];   // a list of points whose labels are visible\n\n    // show/hide labels and/or legend depending on zoom level\n    let previousZoomFactor = 0;   // set to zero so there is always a change in zoom at the start\n    this.board.on('boundingbox', () => {\n      const boundingBox = this.board.getBoundingBox();\n      const zoomFactor = (BOUNDING_BOX[2] - BOUNDING_BOX[0]) / (boundingBox[2] - boundingBox[0]);\n      if (zoomFactor.toFixed(3) === previousZoomFactor.toFixed(3)) return;  // only update if the zoom level changes (rounded due to imprecision)\n\n      let occupiedCoordinates = []; // a list of coordinate tuples that tracks which spaces are being occupied by labels\n      // compute which spaces are occupied\n      for (let point of this.subjectsWithLabels) {\n        occupiedCoordinates.push(getCoordinate(point));\n      }\n\n      // first try to add new subject labels if there's space\n      this.board.suspendUpdate();\n      for (let point of this.points) {\n        if (this.subjectsWithLabels.includes(point)) continue;\n\n        const coordinate = getCoordinate(point);\n        \n        if (this.subjectsWithLabels.length < 1 || isFreeSpace(coordinate, occupiedCoordinates)) {\n          point.setAttribute({withLabel: true});\n          this.subjectsWithLabels.unshift(point);\n          occupiedCoordinates.push(coordinate);\n        } else {\n          point.setAttribute({withLabel: false});\n        }\n      }\n\n      // then delete subject labels if it's too full\n      for (let point of this.subjectsWithLabels) {\n        const coordinate = getCoordinate(point);\n        const otherCoordinates = occupiedCoordinates.filter((coord) => {return JSON.stringify(coord) !== JSON.stringify(coordinate);});\n        if (!isFreeSpace(coordinate, otherCoordinates)) {\n          point.setAttribute({withLabel: false});\n          occupiedCoordinates = otherCoordinates;\n          this.subjectsWithLabels = this.subjectsWithLabels.filter((subject) => {return subject !== point});\n        }\n      }\n      this.board.unsuspendUpdate();\n      \n      // show/hide legend once zoomed in enough (only for mobile)\n      if (this.isMobile && zoomFactorChange(zoomFactor, previousZoomFactor, MOBILE_LEGEND_ZOOM_THRESHOLD)) {\n        document.getElementById('jsxlegend').style.display = (zoomFactor >= MOBILE_LEGEND_ZOOM_THRESHOLD) ? 'none' : ''; // none is hidden, blank is shown\n      }\n\n      previousZoomFactor = zoomFactor;\n    }); \n  }\n\n  createMouseCoordinates() {\n     // create coordinates at mouse\n     let mouseCoordinates = this.board.create('point', [0, 0], {\n      visible: false,\n      fixed: true,\n      size: 2, \n      fillColor: 'black', \n      highlightFillColor: 'black', \n      fillOpacity: 0.7, \n      highlightFillOpacity: 0.7, \n      highlightStrokeWidth: 0,\n      strokeWidth: 0,   // disable stroke so only fill is considered\n      precision: {  // ensures always highlighted\n        touch: 0,\n        mouse: 0,\n        pen: 0\n      }\n    });\n    mouseCoordinates.label.setAttribute({offset: [7, 13]}); // set offset of coordinates at mouse\n    mouseCoordinates.label.setAttribute({cssClass: \"mouseCoordinates\"});\n\n    // update position of mouse coordinates\n    let previousCoordinates = [0, 0];   // tracks whether there has been a change in coordinates (only update on change for optimisation)\n    let previouslyVisible = false;      // tracks whether coordinates were previously shown (for optimisation)\n    let updateMouseCoordinates = () => {\n      if (this.subjects.length < 1) return false;\n\n      let coords = new JXG.Coords(COORDS_BY_SCREEN, this.board.getMousePosition(), this.board).usrCoords.slice(1);\n      let nearestX = Math.round(coords[0]);\n\n      if (nearestX >= -1 && nearestX <= 101) {\n        // adds leeway so you don't have to get exactly 0 or 100\n        if (nearestX <= 0) nearestX = 0;\n        if (nearestX >= 100) nearestX = 100;  \n\n        // pick the closest subject to select\n        let closestSubject = this.subjects.reduce((subjectCode1, subjectCode2) => {  // get the subject with raw score closest to the cursor\n          return (Math.abs(calculateScaledScore(nearestX, subjectCode1, this.props.year) - coords[1]) < Math.abs(calculateScaledScore(nearestX, subjectCode2, this.props.year) - coords[1])) ? subjectCode1 : subjectCode2;\n        })\n        let nearestY = calculateScaledScore(nearestX, closestSubject, this.props.year);\n\n        // show coordinates if previously hidden\n        if (!previouslyVisible) {\n          this.board.suspendUpdate();\n          mouseCoordinates.showElement();\n          previouslyVisible = true;\n        }\n\n        // only update if the coordinates have actually changed\n        let coordinates = [nearestX, nearestY];\n        if (nearestX === previousCoordinates[0] && nearestY === previousCoordinates[1]) return false;\n        previousCoordinates = coordinates;\n        \n        // move the point to the mouse and update it's name to be it's coordinate\n        this.board.suspendUpdate();\n        mouseCoordinates.moveTo(coordinates);\n        mouseCoordinates.setAttribute({name: `(${nearestX.toFixed(0)}, ${nearestY.toFixed(2)})`});\n        this.board.unsuspendUpdate();\n      } else {\n        if (previouslyVisible) {\n          mouseCoordinates.hideElement();\n          previouslyVisible = false;\n        }\n      }\n    }\n    this.board.on('touchstart', updateMouseCoordinates);\n    this.board.on('pointermove', updateMouseCoordinates);\n  }\n\n  clearPoints() {\n    // clear the points which show the raw score inputted but not the graphs. useful if only the raw score changes and not the subjects\n    let objectsList = [...this.board.objectsList];\n    for (let index = objectsList.length - 1; index >= 0; index -= 1) {\n      let object = objectsList[index];\n      if ((object.elType === \"point\" && object.Xjc !== null))\n        this.board.removeObject(object.id);\n    }\n  }\n\n  componentDidUpdate() {\n    this.board.suspendUpdate();\n    this.legend.suspendUpdate();\n\n    let previousSubjects = [...this.subjects];\n    this.subjects = Object.keys(this.props.subjects).filter((subjectCode) => {return this.props.subjects[subjectCode] !== undefined}); // this is a list, whereas this.props.subjects is an object\n    this.subjectsHaveChanged = !(JSON.stringify(previousSubjects) === JSON.stringify(this.subjects));\n    \n    if (this.subjectsHaveChanged || this.year !== this.props.year) {\n      this.year = this.props.year;  // track the year that was previously to check whether the year has changed\n      this.clearBoard();\n      if (this.subjects.length > 0) this.plotScalingFunctions();\n    }\n    if (this.subjectsHaveChanged) {\n      this.clearLegend();\n      if (this.subjects.length > 0) this.createLegend();\n    } else {\n      this.clearPoints();\n    }\n    this.plotPoints();\n\n    this.board.unsuspendUpdate();\n    this.legend.unsuspendUpdate();\n  }\n\n  render() {\n    this.isMobile = this.maxWidth < 400;\n\n    this.maxWidth = document.querySelector('.section-inner').getBoundingClientRect().width;\n    this.graphHeight = Math.abs(this.maxWidth * (BOUNDING_BOX[1] - BOUNDING_BOX[3]) / (BOUNDING_BOX[2] - BOUNDING_BOX[0]));  // ensures that 1x1 aspect ratio is maintained\n    \n    return(\n      <div style={{position: \"relative\"}}>\n        <div id=\"jsxgraph\" style={{width: this.maxWidth, height: this.graphHeight}}></div>\n        <div id=\"jsxlegend\" style={{position: \"absolute\", top: this.graphHeight - 250 /* estimate, will be accurately calculated later */, right: 0, width: LEGEND_WIDTH, height: this.graphHeight, zIndex: -1}}></div>\n      </div>\n    );\n  }\n}"],"names":["COLORS","BOUNDING_BOX","JXG","ScalingGraph","this","board","axis","maxFrameRate","boundingbox","maxboundingbox","showCopyright","showInfobox","zoom","factorX","factorY","wheel","needShift","min","max","pinchHorizontal","pinchVertical","pinchSensitivity","pan","enabled","needTwoFingers","navbar","strokeColor","fillColor","highlightFillColor","padding","position","fontSize","cursor","zIndex","right","bottom","legend","registerEvents","showNavigation","addZoomLevelListeners","createMouseCoordinates","originalObjects","objectsList","points","subjects","year","componentDidUpdate","index","length","object","elType","htmlStr","visProp","cssclass","Xjc","includes","removeObject","id","entries","subjectIndex","subjectCode","scalingData","getScalingData","props","a","b","c","create","x","Math","exp","hasPoint","y","legendObjectsList","subjectsNames","map","SUBJECTS","longestSubjectName","reduce","subject1","subject2","rowHeight","ceil","legendHeight","labels","colors","lines","at","getTextAnchor","scrCoords","maxWidth","document","getElementById","style","top","graphHeight","resizeContainer","boundingBox","getBoundingBox","showLabels","rawScore","scaledScore","calculateScaledScore","point","face","name","withLabel","label","setAttribute","offset","push","getCoordinate","coords","rendNode","offsetWidth","offsetHeight","isFreeSpace","coordinate","occupiedCoordinates","xCoord","yCoord","width","height","minX","minY","maxHeight","subjectsWithLabels","previousZoomFactor","on","zoomFactor","toFixed","suspendUpdate","unshift","otherCoordinates","filter","coord","JSON","stringify","subject","unsuspendUpdate","isMobile","thresholdZoomFactor","zoomFactorChange","display","mouseCoordinates","visible","fixed","size","fillOpacity","highlightFillOpacity","highlightStrokeWidth","strokeWidth","precision","touch","mouse","pen","cssClass","previousCoordinates","previouslyVisible","updateMouseCoordinates","COORDS_BY_SCREEN","getMousePosition","usrCoords","slice","nearestX","round","closestSubject","subjectCode1","subjectCode2","abs","nearestY","showElement","coordinates","moveTo","hideElement","previousSubjects","Object","keys","undefined","subjectsHaveChanged","clearBoard","plotScalingFunctions","clearLegend","createLegend","clearPoints","plotPoints","querySelector","getBoundingClientRect","React"],"sourceRoot":""}