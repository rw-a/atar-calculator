{"version":3,"file":"static/js/834.a8f89e14.chunk.js","mappings":"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","sources":["modules/scaling.js"],"sourcesContent":["import './../css/scaling.css';\nimport React from 'react';\nimport JXG, { COORDS_BY_SCREEN } from 'jsxgraph';\n\nimport { calculateScaledScore } from './results';\n\nimport SUBJECTS from '../data/all_subjects.json';\nimport { getScalingData } from './data';\n  \nconst COLORS = [\n  'steelblue',\n  'orangered',\n  '#05b378', // green\n  'darkviolet',\n  'orange',\n  'brown',\n  'magenta'\n];\n\nconst BOUNDING_BOX = [-9, 103, 113, -6]; // min x, max y, max x, min y\n\nconst LEGEND_WIDTH = 110;\n\nconst SUBJECT_LABELS_ZOOM_THRESHOLD = 1.7;\nconst MOBILE_LEGEND_ZOOM_THRESHOLD = 10;\n\n// replace default font\nJXG.Options.text.cssDefaultStyle = 'z-index: 0';\nJXG.Options.text.highlightCssDefaultStyle = '';\n\nexport default class ScalingGraph extends React.Component {\n  componentDidMount() {\n    this.board = JXG.JSXGraph.initBoard(\"jsxgraph\", { \n      axis: true, \n      maxFrameRate: 30,\n      boundingbox: BOUNDING_BOX, \n      maxboundingbox: [-100, 200, 200, -100],\n      showCopyright: false, \n      showInfobox: false,\n      // showNavigation: false,\n      zoom: {\n        factorX: 1.25,  // horizontal zoom factor (multiplied to JXG.Board#zoomX)\n        factorY: 1.25,  // vertical zoom factor (multiplied to JXG.Board#zoomY)\n        wheel: true,     // allow zooming by mouse wheel or\n                   // by pinch-to-toom gesture on touch devices\n        needShift: false,   // mouse wheel zooming needs pressing of the shift key\n        min: 1,        // minimal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomOut\n        max: 50,       // maximal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomIn\n      \n        pinchHorizontal: false, // Allow pinch-to-zoom to zoom only horizontal axis\n        pinchVertical: false,   // Allow pinch-to-zoom to zoom only vertical axis\n        pinchSensitivity: 7    // Sensitivity (in degrees) for recognizing horizontal or vertical pinch-to-zoom gestures.\n      },\n      pan: {\n        enabled: true,   // Allow panning\n        needTwoFingers: false, // panning is done with two fingers on touch devices\n        needShift: false, // mouse panning needs pressing of the shift key\n      },\n      navbar:  {\n        strokeColor: '#333333',\n        fillColor: 'transparent',\n        highlightFillColor: '#aaaaaa',\n        padding: '0px',\n        position: 'absolute',\n        fontSize: '14px',\n        cursor: 'pointer',\n        zIndex: '100',\n        right: '5px',\n        bottom: '0px',\n      }\n    });\n    \n    this.legend = JXG.JSXGraph.initBoard(\"jsxlegend\", { \n      boundingbox: [0, 120, 20, 0], // min x, max y, max x, min y\n      maxFrameRate: 1,\n      registerEvents: false,\n      showCopyright: false, \n      showInfobox: false,\n      showNavigation: false,\n      zoom: {\n        factorX: 1, \n        factorY: 1, \n        wheel: false,    \n        needShift: true, \n        min: 1,      \n        max: 1, \n      \n        pinchHorizontal: false,\n        pinchVertical: false, \n        pinchSensitivity: 7 \n      },\n      pan: {\n        enabled: false,\n        needTwoFingers: true,\n        needShift: true,\n      },\n    }); \n\n    this.addZoomLevelListeners(); // this could be further optimised by only updating subject label listener, not whole legend listener\n    this.createMouseCoordinates();\n\n    this.originalObjects = [...this.board.objectsList]; // this needs to be after the mouse coordinates is created so it is preserved\n    this.points = [];\n    this.subjects = [];\n    this.year = 2022;\n\n    this.componentDidUpdate();\n  }\n\n  clearBoard() {\n    let objectsList = [...this.board.objectsList];\n    for (let index = objectsList.length - 1; index >= 0; index -= 1) {\n      let object = objectsList[index];\n      if (object.elType === \"line\" || object.elType === \"curve\" || (object.elType === \"text\" && object.htmlStr.length > 3 && object.visProp.cssclass !== \"mouseCoordinates\") || (object.elType === \"point\" && object.Xjc !== null) || !this.originalObjects.includes(object))\n        this.board.removeObject(object.id);\n    }\n  }\n\n  plotScalingFunctions() {\n    for (let [subjectIndex, subjectCode] of this.subjects.entries()) {  // entries on a list does enumerate\n      // create function\n      const scalingData = getScalingData(this.props.year);\n      let a = scalingData[subjectCode][\"a\"];\n      let b = scalingData[subjectCode][\"b\"];\n      let c = scalingData[subjectCode][\"c\"];\n      let subjectFunction = this.board.create('functiongraph', [function(x){\n        return (a / (1 + Math.exp(-b * (x - c))));\n      }, 0, 100], {strokeColor: COLORS[subjectIndex % COLORS.length]});   // modulus ensures colours repeat if exhausted\n      subjectFunction.hasPoint = function(x, y) {return false;}; // disable highlighting\n    }\n  }\n\n  clearLegend() {\n    let legendObjectsList = [...this.legend.objectsList];\n    for (let index = legendObjectsList.length - 1; index >= 0; index -= 1) {\n      let object = legendObjectsList[index];\n      this.legend.removeObject(object.id);\n    }\n  }\n\n  createLegend() {\n    let subjectsNames = this.subjects.map((subjectCode) => {return SUBJECTS[subjectCode]});\n    let longestSubjectName = subjectsNames.reduce((subject1, subject2) => {return (subject1.length > subject2.length) ? subject1 : subject2});\n    let numLines = Math.ceil(longestSubjectName.length / 12);\n    let rowHeight = numLines * 9 + 10;\n\n    let legend = this.legend.create('legend', [0, 100], {labels: subjectsNames, colors: COLORS, rowHeight: rowHeight} );\n\n    let legendHeight = legend.lines.at(-1).getTextAnchor().scrCoords.at(-1) + rowHeight + this.maxWidth / 30;\n    document.getElementById('jsxlegend').style.top = `${this.graphHeight - legendHeight}px`;\n    this.legend.resizeContainer(LEGEND_WIDTH, legendHeight, false, true);\n  }\n\n  plotPoints() {\n    // determine whether to show the points, at the current zoom level\n    let boundingBox = this.board.getBoundingBox();\n    let zoomFactor = (BOUNDING_BOX[2] - BOUNDING_BOX[0]) / (boundingBox[2] - boundingBox[0]);\n    let showLabels = (zoomFactor >= SUBJECT_LABELS_ZOOM_THRESHOLD);\n\n    for (let subjectCode of this.subjects) {\n      // plot raw score input\n      let rawScore = this.props.subjects[subjectCode];\n      if (rawScore) {\n        let scaledScore = calculateScaledScore(rawScore, subjectCode, this.props.year);\n        let point = this.board.create('point', [rawScore, scaledScore], {face: \"cross\", name: SUBJECTS[subjectCode], withLabel: true});\n        point.label.setAttribute({offset: [10, -4]});\n        if (!showLabels) point.setAttribute({withLabel: false});\n        point.hasPoint = function(x, y) {return false;}; // disable highlighting\n        this.points.push(point);\n      }\n    }\n  }\n\n  addZoomLevelListeners() {\n    function zoomFactorChange(zoomFactor, previousZoomFactor, thresholdZoomFactor) {\n      // tests whether the zoom factor has crossed the threshold (for optimisation purposes so no redundant attribute setting)\n      if (zoomFactor >= thresholdZoomFactor) {\n        return previousZoomFactor < thresholdZoomFactor;\n      } else {\n        return previousZoomFactor > thresholdZoomFactor;\n      }\n    }\n\n    this.subjectsWithLabels = [];   // a list of points whose labels are visible\n\n    // show/hide labels and/or legend depending on zoom level\n    let previousZoomFactor = 0;   // set to zero so there is always a change in zoom at the start\n    this.board.on('boundingbox', () => {\n      const boundingBox = this.board.getBoundingBox();\n      const zoomFactor = (BOUNDING_BOX[2] - BOUNDING_BOX[0]) / (boundingBox[2] - boundingBox[0]);\n      if (zoomFactor.toFixed(3) === previousZoomFactor.toFixed(3)) return;  // only update if the zoom level changes (rounded due to imprecision)\n      \n      this.autoHideSubjectLabels();\n\n      // show/hide legend once zoomed in enough (only for mobile)\n      if (this.isMobile && zoomFactorChange(zoomFactor, previousZoomFactor, MOBILE_LEGEND_ZOOM_THRESHOLD)) {\n        document.getElementById('jsxlegend').style.display = (zoomFactor >= MOBILE_LEGEND_ZOOM_THRESHOLD) ? 'none' : ''; // none is hidden, blank is shown\n      }\n\n      previousZoomFactor = zoomFactor;\n    }); \n  }\n\n  autoHideSubjectLabels() {\n    // returns a tuple representing a rectangle of space [x, y, width, height]\n    function getCoordinate(point) {\n      /* These values include the point itself (whereas the current versions do not) so a larger area is considered occupied\n      const xCoord = point.coords.scrCoords[1];\n      const yCoord = point.coords.scrCoords[2];\n      const width =  point.label.rendNode.offsetWidth + Math.abs(point.label.visProp.offset[0]);\n      const height = point.label.rendNode.offsetHeight + Math.abs(point.label.visProp.offset[1]);   // only works because text below point\n      */\n\n      const xCoord = point.label.coords.scrCoords[1];\n      const yCoord = point.label.coords.scrCoords[2];\n      const width =  point.label.rendNode.offsetWidth;\n      const height = point.label.rendNode.offsetHeight;\n      return [xCoord, yCoord, width, height];\n    }\n    \n    // only show labels if they don't overlap with others\n    function isFreeSpace(coordinate, occupiedCoordinates) {\n      const [xCoord, yCoord, width, height] = coordinate;\n      for (const [minX, minY, maxWidth, maxHeight] of occupiedCoordinates) {\n        const xCollision = (\n          (xCoord >= minX && xCoord <= minX + maxWidth) || (xCoord + width >= minX && xCoord + width <= minX + maxWidth)  || // check if xCoord is within occupied space\n          (minX >= xCoord && minX <= xCoord + width) || (minX + maxWidth >= xCoord && minX + maxWidth <= xCoord + width)     // check if occupied coordinate is within xCoord\n        );\n        const yCollision = (\n          (yCoord >= minY && yCoord <= minY + maxHeight) || (yCoord + height >= minY && yCoord + height <= minY + maxHeight) ||\n          (minY >= yCoord && minY <= yCoord + height) || (minY + maxHeight >= yCoord && minY + maxHeight <= yCoord + height)\n          );\n        if (xCollision && yCollision) return false;\n      }\n      return true;\n    }\n\n\n    let occupiedCoordinates = []; // a list of coordinate tuples that tracks which spaces are being occupied by labels\n    // compute which spaces are occupied\n    for (let point of this.subjectsWithLabels) {\n      occupiedCoordinates.push(getCoordinate(point));\n    }\n\n    this.board.suspendUpdate();\n\n    // first try to add new subject labels if there's space\n    for (let point of this.points) {\n      if (this.subjectsWithLabels.includes(point)) continue;\n\n      const coordinate = getCoordinate(point);\n      \n      if (this.subjectsWithLabels.length < 1 || isFreeSpace(coordinate, occupiedCoordinates)) {\n        point.setAttribute({withLabel: true});\n        this.subjectsWithLabels.unshift(point);\n        occupiedCoordinates.push(coordinate);\n      } else {\n        if (point.hasLabel) point.setAttribute({withLabel: false});\n      }\n    }\n\n    // then delete subject labels if it's too full\n    for (let point of this.subjectsWithLabels) {\n      const coordinate = getCoordinate(point);\n      const otherCoordinates = occupiedCoordinates.filter((coord) => {return coord[0] !== coordinate[0] || coord[1] !== coordinate[1] || coord[2] !== coordinate[2] || coord[3] !== coordinate[3];});\n      if (!isFreeSpace(coordinate, otherCoordinates)) {\n        point.setAttribute({withLabel: false});\n        occupiedCoordinates = otherCoordinates;\n        this.subjectsWithLabels = this.subjectsWithLabels.filter((subject) => {return subject !== point});\n      }\n    }\n\n    this.board.unsuspendUpdate();\n  }\n\n  createMouseCoordinates() {\n     // create coordinates at mouse\n     let mouseCoordinates = this.board.create('point', [0, 0], {\n      visible: false,\n      fixed: true,\n      size: 2, \n      fillColor: 'black', \n      highlightFillColor: 'black', \n      fillOpacity: 0.7, \n      highlightFillOpacity: 0.7, \n      highlightStrokeWidth: 0,\n      strokeWidth: 0,   // disable stroke so only fill is considered\n      precision: {  // ensures always highlighted\n        touch: 0,\n        mouse: 0,\n        pen: 0\n      }\n    });\n    mouseCoordinates.label.setAttribute({offset: [7, 13]}); // set offset of coordinates at mouse\n    mouseCoordinates.label.setAttribute({cssClass: \"mouseCoordinates\"});\n\n    // update position of mouse coordinates\n    let previousCoordinates = [0, 0];   // tracks whether there has been a change in coordinates (only update on change for optimisation)\n    let previouslyVisible = false;      // tracks whether coordinates were previously shown (for optimisation)\n    let updateMouseCoordinates = () => {\n      if (this.subjects.length < 1) return false;\n\n      let coords = new JXG.Coords(COORDS_BY_SCREEN, this.board.getMousePosition(), this.board).usrCoords.slice(1);\n      let nearestX = Math.round(coords[0]);\n\n      if (nearestX >= -1 && nearestX <= 101) {\n        // adds leeway so you don't have to get exactly 0 or 100\n        if (nearestX <= 0) nearestX = 0;\n        if (nearestX >= 100) nearestX = 100;  \n\n        // pick the closest subject to select\n        let closestSubject = this.subjects.reduce((subjectCode1, subjectCode2) => {  // get the subject with raw score closest to the cursor\n          return (Math.abs(calculateScaledScore(nearestX, subjectCode1, this.props.year) - coords[1]) < Math.abs(calculateScaledScore(nearestX, subjectCode2, this.props.year) - coords[1])) ? subjectCode1 : subjectCode2;\n        })\n        let nearestY = calculateScaledScore(nearestX, closestSubject, this.props.year);\n\n        // show coordinates if previously hidden\n        if (!previouslyVisible) {\n          this.board.suspendUpdate();\n          mouseCoordinates.showElement();\n          previouslyVisible = true;\n        }\n\n        // only update if the coordinates have actually changed\n        let coordinates = [nearestX, nearestY];\n        if (nearestX === previousCoordinates[0] && nearestY === previousCoordinates[1]) return false;\n        previousCoordinates = coordinates;\n        \n        // move the point to the mouse and update it's name to be it's coordinate\n        this.board.suspendUpdate();\n        mouseCoordinates.moveTo(coordinates);\n        mouseCoordinates.setAttribute({name: `(${nearestX.toFixed(0)}, ${nearestY.toFixed(2)})`});\n        this.board.unsuspendUpdate();\n      } else {\n        if (previouslyVisible) {\n          mouseCoordinates.hideElement();\n          previouslyVisible = false;\n        }\n      }\n    }\n    this.board.on('touchstart', updateMouseCoordinates);\n    this.board.on('pointermove', updateMouseCoordinates);\n  }\n\n  clearPoints() {\n    // clear the points which show the raw score inputted but not the graphs. useful if only the raw score changes and not the subjects\n    this.points = [];\n    this.subjectsWithLabels = [];\n\n    let objectsList = [...this.board.objectsList];\n    for (let index = objectsList.length - 1; index >= 0; index -= 1) {\n      let object = objectsList[index];\n      if ((object.elType === \"point\" && object.Xjc !== null))\n        this.board.removeObject(object.id);\n    }\n  }\n\n  componentDidUpdate() {\n    this.board.suspendUpdate();\n    this.legend.suspendUpdate();\n\n    let previousSubjects = [...this.subjects];\n    this.subjects = Object.keys(this.props.subjects).filter((subjectCode) => {return this.props.subjects[subjectCode] !== undefined}); // this is a list, whereas this.props.subjects is an object\n    this.subjectsHaveChanged = !(JSON.stringify(previousSubjects) === JSON.stringify(this.subjects));\n    \n    if (this.subjectsHaveChanged || this.year !== this.props.year) {\n      this.year = this.props.year;  // track the year that was previously to check whether the year has changed\n      this.clearBoard();\n      if (this.subjects.length > 0) this.plotScalingFunctions();\n    }\n    if (this.subjectsHaveChanged) {\n      this.clearLegend();\n      if (this.subjects.length > 0) this.createLegend();\n    }\n\n    this.clearPoints();\n    this.plotPoints();\n    this.autoHideSubjectLabels();\n\n    this.board.unsuspendUpdate();\n    this.legend.unsuspendUpdate();\n  }\n\n  render() {\n    this.isMobile = this.maxWidth < 400;\n\n    this.maxWidth = document.querySelector('.section-inner').getBoundingClientRect().width;\n    this.graphHeight = Math.abs(this.maxWidth * (BOUNDING_BOX[1] - BOUNDING_BOX[3]) / (BOUNDING_BOX[2] - BOUNDING_BOX[0]));  // ensures that 1x1 aspect ratio is maintained\n    \n    return(\n      <div style={{position: \"relative\"}}>\n        <div id=\"jsxgraph\" style={{width: this.maxWidth, height: this.graphHeight}}></div>\n        <div id=\"jsxlegend\" style={{position: \"absolute\", top: this.graphHeight - 250 /* estimate, will be accurately calculated later */, right: 0, width: LEGEND_WIDTH, height: this.graphHeight, zIndex: -1}}></div>\n      </div>\n    );\n  }\n}"],"names":["COLORS","BOUNDING_BOX","JXG","ScalingGraph","this","board","axis","maxFrameRate","boundingbox","maxboundingbox","showCopyright","showInfobox","zoom","factorX","factorY","wheel","needShift","min","max","pinchHorizontal","pinchVertical","pinchSensitivity","pan","enabled","needTwoFingers","navbar","strokeColor","fillColor","highlightFillColor","padding","position","fontSize","cursor","zIndex","right","bottom","legend","registerEvents","showNavigation","addZoomLevelListeners","createMouseCoordinates","originalObjects","objectsList","points","subjects","year","componentDidUpdate","index","length","object","elType","htmlStr","visProp","cssclass","Xjc","includes","removeObject","id","entries","subjectIndex","subjectCode","scalingData","getScalingData","props","a","b","c","create","x","Math","exp","hasPoint","y","legendObjectsList","subjectsNames","map","SUBJECTS","longestSubjectName","reduce","subject1","subject2","rowHeight","ceil","legendHeight","labels","colors","lines","at","getTextAnchor","scrCoords","maxWidth","document","getElementById","style","top","graphHeight","resizeContainer","boundingBox","getBoundingBox","showLabels","rawScore","scaledScore","calculateScaledScore","point","face","name","withLabel","label","setAttribute","offset","push","subjectsWithLabels","previousZoomFactor","on","zoomFactor","toFixed","autoHideSubjectLabels","isMobile","thresholdZoomFactor","zoomFactorChange","display","getCoordinate","coords","rendNode","offsetWidth","offsetHeight","isFreeSpace","coordinate","occupiedCoordinates","xCoord","yCoord","width","height","minX","minY","maxHeight","suspendUpdate","unshift","hasLabel","otherCoordinates","filter","coord","subject","unsuspendUpdate","mouseCoordinates","visible","fixed","size","fillOpacity","highlightFillOpacity","highlightStrokeWidth","strokeWidth","precision","touch","mouse","pen","cssClass","previousCoordinates","previouslyVisible","updateMouseCoordinates","COORDS_BY_SCREEN","getMousePosition","usrCoords","slice","nearestX","round","closestSubject","subjectCode1","subjectCode2","abs","nearestY","showElement","coordinates","moveTo","hideElement","previousSubjects","Object","keys","undefined","subjectsHaveChanged","JSON","stringify","clearBoard","plotScalingFunctions","clearLegend","createLegend","clearPoints","plotPoints","querySelector","getBoundingClientRect","React"],"sourceRoot":""}